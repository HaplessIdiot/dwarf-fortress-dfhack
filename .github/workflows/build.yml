pkgname=dwarf-fortress-dfhack
pkgver=53.03
pkgrel=1
pkgdesc="Dwarf Fortress Classic ${pkgver} with DFHack; includes optional pinned runtime libs"
arch=('x86_64')
url="https://www.bay12games.com/dwarves/"
license=('custom')
depends=('sdl2' 'openal' 'libpng' 'freetype2' 'gcc-libs' 'glibc')
makedepends=('curl' 'tar' 'xz' 'pacman-contrib')
optdepends=('dfhack: for DFHack features (bundled by this package)')

# DFHack tag matching DF ${pkgver}
_dfhack_tag=53.03-r1

# Sources (use exact Bay12 URL you supplied)
source=(
  "df-53.03-linux.tar.bz2::https://www.bay12games.com/dwarves/df_53_03_linux.tar.bz2"
  "dfhack-${_dfhack_tag}-linux-x86_64.tar.xz::https://github.com/DFHack/dfhack/releases/download/${_dfhack_tag}/dfhack-${_dfhack_tag}-linux-x86_64.tar.xz"
  "LICENSE"
)
# Update with real checksums after a successful run
sha256sums=(
  'SKIP'
  'SKIP'
  'SKIP'
)

# Install root (versioned)
_instroot="/opt/dwarf-fortress/${pkgver}"

prepare() {
  set -euo pipefail

  # Ensure sources exist (makepkg will download them); extract them for packaging
  mkdir -p "${srcdir}/df" "${srcdir}/dfhack"

  # Extract DF (bz2)
  tar -xf "${srcdir}/df-53.03-linux.tar.bz2" -C "${srcdir}/df"

  # Extract DFHack (xz)
  tar -xf "${srcdir}/dfhack-${_dfhack_tag}-linux-x86_64.tar.xz" -C "${srcdir}/dfhack"

  # Generate a desktop file in srcdir so it's available during package()
  cat > "${srcdir}/dwarf-fortress.desktop" <<'EOF'
[Desktop Entry]
Type=Application
Name=Dwarf Fortress (DFHack)
Comment=Dwarf Fortress Classic with DFHack utilities
Exec=dwarf-fortress
Icon=dwarf-fortress
Categories=Game;Simulation;
Terminal=false
EOF
}

package() {
  set -euo pipefail

  # Create install root and copy DF files
  install -dm755 "${pkgdir}${_instroot}"
  cp -r "${srcdir}/df/"* "${pkgdir}${_instroot}/"

  # Overlay DFHack files (DFHack provides a df launcher that wraps DF)
  cp -r "${srcdir}/dfhack/"* "${pkgdir}${_instroot}/"

  # Create a lib directory for pinned/shared libs
  install -dm755 "${pkgdir}${_instroot}/lib"

  # Copy a minimal set of common runtime SONAMEs from the build host (best-effort).
  # These will be used by the wrapper via LD_LIBRARY_PATH if present in pinned_libs or on the builder.
  syslibdir="/usr/lib"
  for so in libc.so.6 libm.so.6 libstdc++.so.6 libgcc_s.so.1; do
    if [[ -e "${syslibdir}/${so}" ]]; then
      install -m644 "${syslibdir}/${so}" "${pkgdir}${_instroot}/lib/${so}"
    fi
  done

  # Allow optional pinned libs provided at build time in srcdir/pinned_libs/
  if [[ -d "${srcdir}/pinned_libs" ]]; then
    for so in libc.so.6 libm.so.6 libstdc++.so.6 libgcc_s.so.1; do
      if [[ -e "${srcdir}/pinned_libs/${so}" ]]; then
        install -m644 "${srcdir}/pinned_libs/${so}" "${pkgdir}${_instroot}/lib/${so}"
      fi
    done
  fi

  # Binary wrapper that prefers bundled libs and launches DF (DFHack-enabled)
  install -dm755 "${pkgdir}/usr/bin"
  cat > "${pkgdir}/usr/bin/dwarf-fortress" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

ROOT="/opt/dwarf-fortress/53.03"
LIBDIR="$ROOT/lib"

# If pinned/bundled libs exist, prefer them
if [[ -d "$LIBDIR" && "$(ls -A "$LIBDIR" 2>/dev/null || true)" ]]; then
  export LD_LIBRARY_PATH="$LIBDIR:${LD_LIBRARY_PATH:-}"
fi

cd "$ROOT"
# DFHack normally provides ./df that wraps the real binary; execute it so DFHack is active
exec ./df "$@"
EOF
  chmod 755 "${pkgdir}/usr/bin/dwarf-fortress"

  # Desktop entry
  install -dm755 "${pkgdir}/usr/share/applications"
  install -m644 "${srcdir}/dwarf-fortress.desktop" "${pkgdir}/usr/share/applications/dwarf-fortress.desktop"

  # Icon (if available in DF data)
  if [[ -f "${pkgdir}${_instroot}/data/art/icon.png" ]]; then
    install -dm755 "${pkgdir}/usr/share/icons/hicolor/256x256/apps"
    install -m644 "${pkgdir}${_instroot}/data/art/icon.png" "${pkgdir}/usr/share/icons/hicolor/256x256/apps/dwarf-fortress.png"
  fi

  # License
  install -dm755 "${pkgdir}/usr/share/licenses/${pkgname}"
  install -m644 "${srcdir}/LICENSE" "${pkgdir}/usr/share/licenses/${pkgname}/LICENSE"
}
